"use strict";

const path = require('path');

const fs = require('fs');

const crypto = require('crypto');

function round(value) {
  return value >= 10 ? value : `0${value}`;
}

module.exports = {
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  getNowDateTime(dateObj) {
    let now = new Date();

    if (dateObj) {
      now = dateObj;
    }

    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const hour = now.getHours();
    const minutes = now.getMinutes();
    const second = now.getSeconds();
    return `${year}-${round(month + 1)}-${round(day)} ${round(hour)}:${round(minutes)}:${round(second)}`;
  },

  getUserCookierName() {
    return 'wcms5u';
  },

  object2base64(value) {
    let str = JSON.stringify(value);
    str = Buffer.from(str);
    str = str.toString('base64');
    return str;
  },

  base642object(value) {
    const str = Buffer.from(value, 'base64');
    return JSON.parse(str);
  },

  base642String(value) {
    const str = Buffer.from(value, 'base64');
    return str.toString();
  },

  string2base64(value) {
    let str = Buffer.from(value);
    str = str.toString('base64');
    return str;
  },

  getWcms4Token(uid, rid) {
    let tokenStr = 'wcms4.0|';
    tokenStr += `${rid}|`;
    tokenStr += `${uid}|`;
    tokenStr += this.getNowDateTime();
    return encodeURIComponent(this.desEncrypt(tokenStr));
  },

  validWcms4Token(token) {
    let tokenStr = decodeURIComponent(token);
    tokenStr = this.desDecrypt(tokenStr);
    const result = {
      rid: null,
      uid: null,
      time: 0
    };
    const tokenArray = tokenStr.split('|');

    if (tokenArray.length === 4) {
      result.rid = tokenArray[1];
      result.uid = tokenArray[2];
      result.time = new Date().getTime() - parseInt(tokenArray[3]);
    }

    return result;
  },

  desEncrypt(str) {
    const key = Buffer.from('rogernet', 'ascii');
    const iv = Buffer.from('rogernet', 'ascii');
    const alg = 'des-cbc';
    const cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(true);
    let ciph = cipher.update(str, 'ascii', 'base64');
    ciph += cipher.final('base64');
    return ciph;
  },

  desDecrypt(str) {
    const key = Buffer.from('rogernet', 'ascii');
    const iv = Buffer.from('rogernet', 'ascii');
    const alg = 'des-cbc';
    const ciph = decodeURIComponent(str);
    const decipher = crypto.createDecipheriv(alg, key, iv);
    decipher.setAutoPadding(true);
    let txt = decipher.update(ciph, 'base64', 'ascii');
    txt += decipher.final('ascii');
    return txt;
  },

  geEvidenceDataDir() {
    const root = process.cwd();
    const array = root.split(path.sep);
    array.push('EvidenceData');
    const wcms5Path = array.join(path.sep);
    array.splice(array.length - 3, 3);
    array.push('WCMS4.0');
    array.push('EvidenceData');
    const wcms4Path = array.join(path.sep);

    if (fs.existsSync(wcms4Path)) {
      return wcms4Path;
    }

    if (!fs.existsSync(wcms5Path)) {
      fs.mkdirSync(wcms5Path);
    }

    return wcms5Path;
  }

};
//# sourceMappingURL=commonFun.js.map