<html><head><base href="https://weeky-task-manager.example.com">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weeky: React-Redux Powered Visual Task Management</title>
<script src="https://unpkg.com/react@17.0.2/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone@7.14.7/babel.min.js"></script>
<script src="https://unpkg.com/@reduxjs/toolkit@1.6.0/dist/redux-toolkit.umd.min.js"></script>
<script src="https://unpkg.com/react-redux@7.2.4/dist/react-redux.min.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f0f0;
    }
    h1 {
        color: #333;
        text-align: center;
    }
    h2 {
        color: #444;
    }
    ul {
        list-style-type: none;
        padding: 0;
    }
    li {
        background-color: #fff;
        margin: 5px 0;
        padding: 10px;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    form {
        display: flex;
        margin-bottom: 20px;
        align-items: center;
    }
    input[type="text"] {
        flex-grow: 1;
        padding: 10px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        background-color: #fff;
    }
    .completed {
        text-decoration: line-through;
        color: #888;
    }
    .search-bar {
        margin-bottom: 20px;
        display: flex;
        justify-content: center;
    }
    .search-bar input {
        width: 50%;
        max-width: 300px;
        padding: 10px;
        font-size: 14px;
        border-radius: 5px;
        border: 1px solid #ddd;
    }
    .accordion {
        background-color: #eee;
        color: #444;
        cursor: pointer;
        padding: 18px;
        width: 100%;
        text-align: left;
        border: none;
        outline: none;
        transition: 0.4s;
    }
    .active, .accordion:hover {
        background-color: #ccc;
    }
    .panel {
        padding: 0 18px;
        background-color: white;
        display: none;
        overflow: hidden;
    }
    .trashcan {
        margin-top: 30px;
        background-color: #f8f8f8;
        border-radius: 5px;
        padding: 15px;
    }
    .trashcan-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    .trashcan-header {
        font-size: 18px;
        font-weight: bold;
    }
    .delete-all-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
    }
    .empty-trashcan {
        text-align: center;
        color: #888;
    }
    .trashcan-list {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
    }
    .trashcan-column {
        width: 48%;
    }
    .trashcan-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background-color: #fff;
        margin: 5px 0;
        border-radius: 5px;
    }
    .restore-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
    }
    .columns {
        display: flex;
        justify-content: space-between;
    }
    .column {
        width: 48%;
    }
    .accept-icon {
        width: 20px;
        height: 20px;
        cursor: pointer;
        fill: #4CAF50;
    }
    .accept-icon:hover {
        fill: #45a049;
    }
    .delete-icon {
        width: 20px;
        height: 20px;
        cursor: pointer;
        fill: #f44336;
    }
    .delete-icon:hover {
        fill: #d32f2f;
    }
    .task-actions {
        display: flex;
        align-items: center;
    }
    .task-actions svg {
        margin-left: 10px;
    }
    .restore-icon {
        width: 20px;
        height: 20px;
        cursor: pointer;
        fill: #2196F3;
    }
    .restore-icon:hover {
        fill: #1976D2;
    }
    .trashcan-icon {
        width: 24px;
        height: 24px;
        cursor: pointer;
        fill: #f44336;
    }
    .trashcan-icon:hover {
        fill: #d32f2f;
    }
    .add-task-icon {
        width: 24px;
        height: 24px;
        cursor: pointer;
        fill: #4CAF50;
        margin-left: 10px;
    }
    .add-task-icon:hover {
        fill: #45a049;
    }
    @media (max-width: 768px) {
        .trashcan-list, .columns {
            flex-direction: column;
        }
        .trashcan-column, .column {
            width: 100%;
        }
        .search-bar input {
            width: 80%;
        }
    }
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
// Import necessary packages
const { createSlice, configureStore } = RTK;
const { Provider, useSelector, useDispatch } = ReactRedux;
const { useState, useEffect } = React;

// Create Redux slice for task management
const tasksSlice = createSlice({
    name: 'tasks',
    initialState: {
        everyday: [],
        weekly: [],
        todoList: [],
        byDay: {
            sunday: [], monday: [], tuesday: [], wednesday: [], thursday: [], friday: [], saturday: []
        },
        searchTerm: '',
        trashcan: []
    },
    reducers: {
        // Define task management actions
        addTask: (state, action) => {
            const { type, text } = action.payload;
            state[type].push({ text, completed: false });
        },
        toggleTask: (state, action) => {
            const { type, index } = action.payload;
            state[type][index].completed = !state[type][index].completed;
        },
        deleteTask: (state, action) => {
            const { type, index } = action.payload;
            const deletedTask = state[type].splice(index, 1)[0];
            state.trashcan.push({ ...deletedTask, type, index });
        },
        addDayTask: (state, action) => {
            const { day, text } = action.payload;
            state.byDay[day].push({ text, completed: false });
        },
        toggleDayTask: (state, action) => {
            const { day, index } = action.payload;
            state.byDay[day][index].completed = !state.byDay[day][index].completed;
        },
        deleteDayTask: (state, action) => {
            const { day, index } = action.payload;
            const deletedTask = state.byDay[day].splice(index, 1)[0];
            state.trashcan.push({ ...deletedTask, type: 'byDay', day, index });
        },
        setSearchTerm: (state, action) => {
            state.searchTerm = action.payload;
        },
        loadTasks: (state, action) => {
            return { ...state, ...action.payload };
        },
        restoreTask: (state, action) => {
            const { index } = action.payload;
            const restoredTask = state.trashcan.splice(index, 1)[0];
            if (restoredTask.type === 'byDay') {
                state.byDay[restoredTask.day].splice(restoredTask.index, 0, restoredTask);
            } else {
                state[restoredTask.type].splice(restoredTask.index, 0, restoredTask);
            }
        },
        clearTrashcan: (state) => {
            state.trashcan = [];
        },
        uncheckEverydayTasks: (state) => {
            state.everyday.forEach(task => task.completed = false);
        },
        uncheckWeeklyTasksAndWeekAccordion: (state) => {
            state.weekly.forEach(task => task.completed = false);
            Object.keys(state.byDay).forEach(day => 
                state.byDay[day].forEach(task => task.completed = false)
            );
        }
    }
});

// Destructure actions from tasks slice
const { addTask, toggleTask, deleteTask, addDayTask, toggleDayTask, deleteDayTask, setSearchTerm, loadTasks, restoreTask, clearTrashcan, uncheckEverydayTasks, uncheckWeeklyTasksAndWeekAccordion } = tasksSlice.actions;

// Configure the Redux store
const store = configureStore({
    reducer: tasksSlice.reducer
});

// TaskItem component to render individual tasks
const TaskItem = ({ task, onToggle, onDelete }) => (
    <li>
        <span className={task.completed ? 'completed' : ''}>{task.text}</span>
        <div className="task-actions">
            <svg className="accept-icon" viewBox="0 0 24 24" onClick={onToggle}>
                <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>
            </svg>
            <svg className="delete-icon" viewBox="0 0 24 24" onClick={onDelete}>
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
        </div>
    </li>
);

// TaskBlock component to render a block of tasks with a header
const TaskBlock = ({ title, tasks, onAdd, onToggle, onDelete, searchTerm }) => {
    const [newTask, setNewTask] = useState('');

    // Filter tasks based on the search term
    const filteredTasks = tasks.filter(task =>
        task.text.toLowerCase().includes(searchTerm ? searchTerm.toLowerCase() : '')
    );

    // Handle adding a new task
    const handleSubmit = (e) => {
        e.preventDefault();
        if (newTask.trim()) {
            onAdd(newTask);
            setNewTask('');
        }
    };

    return (
        <div>
            <h2>{title}</h2>
            <form onSubmit={handleSubmit}>
                <input
                    type="text"
                    value={newTask}
                    onChange={(e) => setNewTask(e.target.value)}
                    placeholder="Add a new task"
                />
                <button type="submit" style={{background: 'none', border: 'none', cursor: 'pointer'}}>
                    <svg className="add-task-icon" viewBox="0 0 24 24">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                </button>
            </form>
            <ul>
                {filteredTasks.map((task, index) => (
                    <TaskItem
                        key={index}
                        task={task}
                        onToggle={() => onToggle(index)}
                        onDelete={() => onDelete(index)}
                    />
                ))}
            </ul>
        </div>
    );
};

// DayAccordion component to render tasks for a specific day with an accordion style
const DayAccordion = ({ day, tasks, onAdd, onToggle, onDelete, searchTerm }) => {
    const [isOpen, setIsOpen] = useState(day === new Date().toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase());

    // Filter tasks based on the search term
    const filteredTasks = tasks.filter(task =>
        task.text.toLowerCase().includes(searchTerm ? searchTerm.toLowerCase() : '')
    );

    return (
        <div>
            <button className={`accordion ${isOpen ? 'active' : ''}`} onClick={() => setIsOpen(!isOpen)}>
                {day.charAt(0).toUpperCase() + day.slice(1)}
            </button>
            <div className="panel" style={{ display: isOpen ? 'block' : 'none' }}>
                <TaskBlock
                    title=""
                    tasks={filteredTasks}
                    onAdd={(text) => onAdd(day, text)}
                    onToggle={(index) => onToggle(day, index)}
                    onDelete={(index) => onDelete(day, index)}
                    searchTerm={searchTerm}
                />
            </div>
        </div>
    );
};

// Trashcan component to manage and display deleted tasks
const Trashcan = () => {
    const dispatch = useDispatch();
    const trashedTasks = useSelector(state => state.trashcan);

    // Handle clearing of the entire trashcan
    const handleClearTrashcan = () => {
        if (window.confirm("Are you sure you want to permanently delete all tasks in the trashcan?")) {
            dispatch(clearTrashcan());
        }
    };

    // Component to display a column of trashed tasks
    const TaskColumn = ({ tasks }) => (
        <div className="trashcan-column">
            {tasks.map((task, index) => (
                <div key={index} className="trashcan-item">
                    <span>{task.text}</span>
                    <button 
                        className="restore-button" 
                        onClick={() => dispatch(restoreTask({ index: trashedTasks.indexOf(task) }))}
                        title="Restore task"
                    >
                        <svg className="restore-icon" viewBox="0 0 24 24">
                            <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
                        </svg>
                    </button>
                </div>
            ))}
        </div>
    );

    if (trashedTasks.length === 0) {
        return null; // Hide the trashcan if it's empty
    }

    return (
        <div className="trashcan">
            <div className="trashcan-controls">
                <h3 className="trashcan-header">Trashcan</h3>
                <button className="delete-all-button" onClick={handleClearTrashcan} title="Empty trashcan">
                    <svg className="trashcan-icon" viewBox="0 0 24 24">
                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                    </svg>
                </button>
            </div>
            <div className="trashcan-list">
                <TaskColumn tasks={trashedTasks.slice(0, Math.ceil(trashedTasks.length / 2))} />
                <TaskColumn tasks={trashedTasks.slice(Math.ceil(trashedTasks.length / 2))} />
            </div>
        </div>
    );
};

// Main App component
const App = () => {
    const dispatch = useDispatch();
    const { everyday, weekly, todoList, byDay, searchTerm } = useSelector((state) => state);

    // Load tasks from local storage on initial render
    useEffect(() => {
        const storedTasks = localStorage.getItem('tasks');
        if (storedTasks) {
            dispatch(loadTasks(JSON.parse(storedTasks)));
        }
    }, [dispatch]);

    // Save tasks to local storage whenever task state changes
    useEffect(() => {
        localStorage.setItem('tasks', JSON.stringify({ everyday, weekly, todoList, byDay, searchTerm }));
    }, [everyday, weekly, todoList, byDay, searchTerm]);

    // Uncheck completed tasks at midnight
    useEffect(() => {
        const midnightCheck = () => {
            const now = new Date();
            if (now.getHours() === 0 && now.getMinutes() === 0) {
                dispatch(uncheckEverydayTasks());
                if (now.getDay() === 0) {
                    dispatch(uncheckWeeklyTasksAndWeekAccordion());
                }
            }
        };

        midnightCheck();
        const intervalId = setInterval(midnightCheck, 60000);
        return () => clearInterval(intervalId);
    }, [dispatch]);

    const weekDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

    return (
        <div>
            {/* Header */}
            <h1>Weeky: React-Redux Powered Visual Task Management</h1>

            {/* Search Component */}
            <div className="search-bar">
                <input
                    type="text"
                    placeholder="Search tasks..."
                    value={searchTerm}
                    onChange={(e) => dispatch(setSearchTerm(e.target.value))}
                />
            </div>

            {/* Main Content Section */}
            <div className="columns">
                {/* Left Column: Everyday and Day Accordion Tasks */}
                <div className="column">
                    <TaskBlock
                        title="Everyday Tasks"
                        tasks={everyday}
                        onAdd={(text) => dispatch(addTask({ type: 'everyday', text }))}
                        onToggle={(index) => dispatch(toggleTask({ type: 'everyday', index }))}
                        onDelete={(index) => dispatch(deleteTask({ type: 'everyday', index }))}
                        searchTerm={searchTerm}
                    />
                    {/* Map over days to create an accordion for each */}
                    {weekDays.map(day => (
                        <DayAccordion
                            key={day}
                            day={day}
                            tasks={byDay[day]}
                            onAdd={(day, text) => dispatch(addDayTask({ day, text }))}
                            onToggle={(day, index) => dispatch(toggleDayTask({ day, index }))}
                            onDelete={(day, index) => dispatch(deleteDayTask({ day, index }))}
                            searchTerm={searchTerm}
                        />
                    ))}
                </div>
                
                {/* Right Column: Weekly and Todo List Tasks */}
                <div className="column">
                    <TaskBlock
                        title="Weekly Tasks"
                        tasks={weekly}
                        onAdd={(text) => dispatch(addTask({ type: 'weekly', text }))}
                        onToggle={(index) => dispatch(toggleTask({ type: 'weekly', index }))}
                        onDelete={(index) => dispatch(deleteTask({ type: 'weekly', index }))}
                        searchTerm={searchTerm}
                    />
                    <TaskBlock
                        title="Todo List"
                        tasks={todoList}
                        onAdd={(text) => dispatch(addTask({ type: 'todoList', text }))}
                        onToggle={(index) => dispatch(toggleTask({ type: 'todoList', index }))}
                        onDelete={(index) => dispatch(deleteTask({ type: 'todoList', index }))}
                        searchTerm={searchTerm}
                    />
                </div>
            </div>

            {/* Trashcan Component */}
            <Trashcan />
        </div>
    );
};

// Render the App component, wrapped with the Redux Provider
ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
);
</script>
</body>
</html>